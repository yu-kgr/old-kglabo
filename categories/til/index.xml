<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>TIL on kglabo.com</title>
    <link>https://kglabo.com/categories/til/</link>
    <description>Recent content in TIL on kglabo.com</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 01 Jun 2018 00:00:00 +0000</lastBuildDate>
    <atom:link href="https://kglabo.com/categories/til/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>2018/05 - four week I Learned</title>
      <link>https://kglabo.com/blog/til-201805-four-week/</link>
      <pubDate>Fri, 01 Jun 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201805-four-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [ &#34;ElasticSearch&#34;, &#34;javaScript&#34;, &#34;npm script&#34;, &#34;webpack&#34;, &#34;ES2015&#34;,&#34;マイクロワイヤーフレーム&#34;] --&gt;

&lt;h2 id=&#34;2018-05-28-learned&#34;&gt;2018/05/28 - Learned&lt;/h2&gt;

&lt;p&gt;5月28日（月）のToday I Leaned.&lt;/p&gt;

&lt;h3 id=&#34;elasticsearchについて&#34;&gt;ElasticSearchについて&lt;/h3&gt;

&lt;p&gt;Javaで記述された全文検索ソフトウェア。&lt;br /&gt;
あらかじめ蓄積した大量のデータから指定したキーワードを探し出す機能を持っており、javaのクラスライブラリとして提供されている。&lt;/p&gt;

&lt;h4 id=&#34;oracleやmysqlじゃだめなの&#34;&gt;OracleやMySQLじゃだめなの？&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;DBによって得意不得意があって、全てのケースに対応しているものが存在しない為、使うと便利。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;dbの種類&#34;&gt;DBの種類&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;MySQL&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;矛盾なく永続化することに特化したデータベース&lt;/li&gt;
&lt;li&gt;メリット: SQL と言う高度なクエリ言語、検索トラフィックに対するシステムの拡張は得意&lt;/li&gt;
&lt;li&gt;デメリット: データ量の増加や書き込み速度の拡張は苦手&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Redshift(AWS)：データウェアハウス系のデータベース&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メリット: 大規模なデータの蓄積・分析は得意&lt;/li&gt;
&lt;li&gt;デメリット: 不特定多数のクライアントから同時に利用され、検索リクエストが大規模なユースケースには不向き&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;DynamoDB(AWS)：NoSQL&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;メリット: 幅広い種類の膨大な量のデータを高速かつ動的に整理し分析することが可能&lt;/li&gt;
&lt;li&gt;デメリット: 非リレーショナルな広域分散データベースシステムです。その反面複雑なクエリやソートなどが苦手&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;elasticsearchが得意なこと&#34;&gt;ElasticSearchが得意なこと&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;高度なリアルタイム分析&lt;/li&gt;
&lt;li&gt;大規模分散&lt;/li&gt;
&lt;li&gt;高可用性&lt;/li&gt;
&lt;li&gt;マルチテナンシー&lt;/li&gt;
&lt;li&gt;全文検索&lt;/li&gt;
&lt;li&gt;ドキュメント指向&lt;/li&gt;
&lt;li&gt;スキーマフリー&lt;/li&gt;
&lt;li&gt;RESTfulAPI&lt;/li&gt;
&lt;li&gt;データ保護機能&lt;/li&gt;
&lt;li&gt;形態素解析や n-gram など自然言語的な解析&lt;/li&gt;
&lt;li&gt;簡単にスケールアウト&lt;/li&gt;
&lt;li&gt;kibanaと連携する事によって図で表示する事も可能！&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;npm-scriptについて&#34;&gt;npm scriptについて&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;package.jsonのscriptフィールドにスクリプトを記載すると、コマンドのエイリアスを作成できる。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-json&#34;&gt;&amp;quot;scripts&amp;quot; : {
  &amp;quot;build:dev&amp;quot; : &amp;quot;webpack --mode development&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;webpack&#34;&gt;webpack&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://kglabo.com/blog/til-201805-thaad-week/#webpack%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6&#34;&gt;これの続き&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;loader&#34;&gt;Loader&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Loaderを利用する事で、JavaScript以外のファイルもstaticファイルも同時にbundleする事が可能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://webpack.js.org/loaders/&#34;&gt;いろいろな種類のloader&lt;/a&gt;が存在する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-29-learned&#34;&gt;2018/05/29 - Learned&lt;/h2&gt;

&lt;p&gt;5月29日（火）のToday I Leaned&lt;/p&gt;

&lt;h4 id=&#34;webpack-1&#34;&gt;webpack&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;上記の続き&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;plagin&#34;&gt;Plagin&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;Loaderはファイルの依存関係であった、モジュールタイプの変更に使えたが、PluginはLoaderで賄えない幅広いタスクの実行が可能になる。&lt;/li&gt;
&lt;li&gt;Pluginを利用する場合は、Moduleをrequireした後、new演算子を使ってインスタンス化する必要がある。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;es2015&#34;&gt;ES2015&lt;/h4&gt;

&lt;p&gt;なんか前にも学習してた気がするけど、間が空いてしまって忘れつつあるので、&lt;br /&gt;
改めて備忘録と後々見返す事を兼ねて記載く。&lt;/p&gt;

&lt;h5 id=&#34;ブロックスコープ&#34;&gt;ブロックスコープ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;varは関数定義の&lt;code&gt;{&lt;/code&gt;と&lt;code&gt;}&lt;/code&gt;内じゃないとスコープが作られないので、スコープを作りたい場合は即時関数を利用する必要がある。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 普通に{}でスコープ作った場合
{
  var a = &amp;quot;foo&amp;quot;;
}

if(true){
  var b = &amp;quot;bar&amp;quot;;
}

for(var i = 0; i &amp;lt; 1; i++){
  var c = &amp;quot;buz&amp;quot;;
}

console.log(a); // &amp;quot;foo&amp;quot;
console.log(b); // &amp;quot;bar&amp;quot;
console.log(c); // &amp;quot;buz&amp;quot;

// 即時関数を作った場合（スコープ作られる）
(function(){
  var a = &amp;quot;foo&amp;quot;;
})();

console.log(a); // ReferenceError: a is not defined

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;let/constは、varとは異なりブロックスコープ（&lt;code&gt;{&lt;/code&gt;と&lt;code&gt;}&lt;/code&gt;で囲まれた内部）でしか変数/関数の参照ができない

&lt;ul&gt;
&lt;li&gt;メリット 定義した変数・関数の影響範囲が明確化される&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;{
  let   a = &amp;quot;foo&amp;quot;;
  const B = &amp;quot;bar&amp;quot;;

  console.log(a); // &amp;quot;foo&amp;quot;
  console.log(B); // &amp;quot;bar&amp;quot;
}

console.log(a);
// ReferenceError: a is not defined
console.log(B);
// ReferenceError: B is not defined
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;テンプレートリテラル&#34;&gt;テンプレートリテラル&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;文字列の連結の為に&lt;code&gt;+&lt;/code&gt;や&lt;code&gt;concat()&lt;/code&gt;を利用する必要があったが、下記の形で変数名を参照する事が可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;const user = { name: &#39;Taro&#39;};
console.log(\`${user.name}が入室しました。\`); // &amp;quot;Taroが入室しました、&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;計算式を入れる事も可能。変数が存在しない場合は&lt;code&gt;||&lt;/code&gt;を入れることで分岐される事も可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;console.log(\`${user.name||&amp;quot;匿名&amp;quot;}が入室しました。\`); // &amp;quot;匿名が入室しました、&amp;quot;

const user = {name: &#39;Taro&#39;};
console.log(\`${user.name||&amp;quot;匿名&amp;quot;}が入室しました。\`); // &amp;quot;Taroが入室しました、&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;デフォルト引数&#34;&gt;デフォルト引数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;ES2015からは引数定義の箇所でデフォルト値を設定可能&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;function joinChannel(name = &amp;quot;匿名&amp;quot;) {
  console.log(&#39;${name}さんが入室しました。&#39;)
}

// 匿名さんが入室しました。
joinChannel();

// 太郎さんが入室しました。
joinChannel(&amp;quot;太郎&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;アロー関数&#34;&gt;アロー関数&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;関数定義を省略して書く事が可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 従来の記法
const add = function (a,b) {
  return a + b;
}

// functionを省略可能
const add = (a,b) =&amp;gt; {
  return a + b;
}

// 波括弧とreturnも省略できる場合
const add = (a,b) =&amp;gt; a + b;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2018-05-30-learned&#34;&gt;2018/05/30 - Learned&lt;/h2&gt;

&lt;p&gt;5月30日（水）のToday I Leaned&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;理解度に合わせて基礎をいったり来たり。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;javascript&#34;&gt;JavaScript&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;PrototypeとClass定義について&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;prototypeについて&#34;&gt;Prototypeについて&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;ES2015以前は、classという概念がなかったのでJSの仕様でなんとかclassっぽい事を実現する為に運用でカバーしていたらしい。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/howdy39/items/35729490b024ca295d6c&#34;&gt;図で理解するJavaScriptのプロトタイプチェーン&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;class定義&#34;&gt;class定義&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;これまではクラス定義がなかったのでprototypeにメソッドを追加して対応していた。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var Parson = function(id, name) {
  this.id = id;
  this.name = name;
}

Paeson.prototype.printName(){
  console.log(this.name);
}

var person = newPerson(1,太郎);
person.printName();

&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;2018-05-31-learned&#34;&gt;2018/05/31 - Learned&lt;/h2&gt;

&lt;p&gt;5月31日（木）のToday I Leaned&lt;/p&gt;

&lt;h4 id=&#34;javascript-1&#34;&gt;JavaScript&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;prototypeやclass定義の所で一旦、JavaScript自体について知ったほうが良い気がした為一旦もどる。&lt;/li&gt;
&lt;li&gt;出てくる名称や独自仕様について。&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;イベントとイベントハンドラ&#34;&gt;イベントとイベントハンドラ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;HTML要素に対してかかる（かける）名をイベントと呼び、そりによって起こる現象をイベントハンドラと呼ぶ。&lt;/li&gt;
&lt;li&gt;&amp;lt;要素名 onイベント名=“イベントハンドラ”&amp;gt;&amp;lt;/要素名&amp;gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h6 id=&#34;ホイスティング-巻き上げ&#34;&gt;ホイスティング（巻き上げ）&lt;/h6&gt;

&lt;ul&gt;
&lt;li&gt;JavaScriptには変数を指定した時点、その宣言されたスコープ内で巻き上げ（ホイスティング）という現象が発生する仕様。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/cocottejs/items/143f70e806c61ffafe28&#34;&gt;参考:関数の場合の変数の巻き上げ問題について&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/39_isao/items/d9d80e98b5bd1938bc1d&#34;&gt;参考:やっとわかったjsの「巻き上げ」&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;console.log(x) // ReferenceError: x is not defined（そんなもんねーよ）
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;console.log(x) // undefined（1かはわからんけど、xは存在してるよ）
var x = 1;

// ↓ 内部ではこんな事（ホイスティング）が起きてる
var x;
console.log(x);
x = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;関数定義について&#34;&gt;関数定義について&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;関数定義の方法が「関数宣言文」と「関数定義式」の二種類ある。

&lt;ul&gt;
&lt;li&gt;本質的な違いは「式（Expression）」か「文（Statement)」なのかの違い。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wp-p.info/tpl_rep.php?cat=js-intermediate&amp;amp;fl=r9&#34;&gt;参考:ホスティング宣言の巻き上げについて&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://wp-p.info/tpl_rep.php?cat=js-intermediate&amp;amp;fl=r10&#34;&gt;参考:無名関数 関数式と関数宣言&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/tomcky/items/988fc5f56d019e9dc097&#34;&gt;参考:【JavaScript】関数定義いろいろ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 関数宣言文
function hoge(){
  // ここに処理
}

// 関数定義式（関数リテラル）
var hoge = function (){
  // ここに処理
};
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;関数宣言文の場合は、関数宣言の前に関数を実行してもエラーにならない。&lt;/li&gt;
&lt;li&gt;なぜなら、関数宣言文の場合はブラウザでのレンダリングが完了した時点で関数が生成されている為、宣言する前に実行可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 関数宣言文を実行した場合
hoge(); // 先に呼ばれてるけど &amp;quot;hoge&amp;quot;と表示される

function hoge(){ // 関数宣言した場合は、レンダリングが完了した時点で関数生成済み
  console.log(&amp;quot;hoge&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;関数定義式（関数リテラル）の場合は、関数定義の前に関数を実行するとエラーになる。&lt;/li&gt;
&lt;li&gt;なぜなら、関数定義式の場合は変数に対して代入処理が行われた時点で初めて関数定義される為、代入後じゃないと実行不可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;hoge(); // Uncaught TypeError: hoge is not a function

var hoge = function (){
  console.log(&amp;quot;hoge&amp;quot;);
};
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;マイクロワイヤーフレーム&#34;&gt;マイクロワイヤーフレーム&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;マイクロワイヤーフレームという従来のワイヤーフレームを小さく（100px~300pxぐらいでサイズ決める）して良さを濃集したものがあるらしい。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://uxmilk.jp/66066&#34;&gt;参考:次世代のワイヤーフレーム「マイクロフレーム」とは&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;効能 : つくるのはやい / わかりやすい / 忠実制が少ないので混乱しづらい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;利点&#34;&gt;利点&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;はやい

&lt;ul&gt;
&lt;li&gt;スケッチと同じくらい早く作ることができる&lt;/li&gt;
&lt;li&gt;簡単に作業を繰り返すことができる&lt;/li&gt;
&lt;li&gt;すぐに結果共有が可能&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;わかりやすい

&lt;ul&gt;
&lt;li&gt;プランや要件をわかりやすく伝えることができる&lt;/li&gt;
&lt;li&gt;顧客と協力して同じ視点で作業を反復することが可能&lt;/li&gt;
&lt;li&gt;WFのように捨ててしまう作品に時間をかけすぎない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;忠実性が低いので混乱が少ない

&lt;ul&gt;
&lt;li&gt;めっちゃ最小化されているので、完成品とのギャップを感じづらい&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-6-01-learned&#34;&gt;2018/6/01 - Learned&lt;/h2&gt;

&lt;p&gt;6月01日（金）のToday I Leaned&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;なんだか今週はJavaScript Week。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;javascript-2&#34;&gt;JavaScript&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;関数オブジェクトやらコンストラクタ・インスタンス・クロージャ・プロトタイプなど&lt;/li&gt;
&lt;/ul&gt;

&lt;h5 id=&#34;関数の即時実行と受け渡し&#34;&gt;関数の即時実行と受け渡し&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;javaScriptでは関数の即時実行が可能。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/fewzio/items/a502defb516e75d7e81b&#34;&gt;参考:久しぶりにJavaScriptを思い出す(関数オブジェクト、クロージャ）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 普通に定義して実行する場合
var a = function(){ console.log(&amp;quot;TEST&amp;quot;) };
a(); // var aへの参照と実行 &amp;quot;TEST&amp;quot; と表示される
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 即時実行する場合
var a = function(){ console.log(&amp;quot;TEST&amp;quot;) }(); // var aへの参照と実行 &amp;quot;TEST&amp;quot; と表示される
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;ただ上記は、aに対して何のリテラルも代入しているわけではないので、&lt;code&gt;&amp;quot;TEST&amp;quot;&lt;/code&gt;がコンソールに表示された後、&lt;code&gt;undefined&lt;/code&gt; が出力される。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 即時実行する場合
var a = function(){ console.log(&amp;quot;TEST&amp;quot;) }(); // &amp;quot;TEST&amp;quot;
console.log(a); // aには何も代入されていないのでundefined
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;a自体に値を代入したい場合は&lt;code&gt;return&lt;/code&gt;を利用すると戻り値に1が返ってくる。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 即時実行する場合
var a = function(){ return 1; }(); // aに1が代入される
console.log(a); // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;JavaScriptでは関数を値と同じように受け渡しができるので、下記のように戻り値に関数を定義する事も可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 戻り値を関数にした場合
var a = function () {
  return function () { // 関数を実行した結果、後ろの関数がaに代入される
    console.log(&amp;quot;TEST&amp;quot;);
  }
}();

a(); // &amp;quot;TEST&amp;quot; &amp;amp; 上記の場合はaには何も代入されていないのでundefined（ややこしい）

&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;return&lt;/code&gt;内にプロパティを定義したうえで関数を定義する事も可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// 戻り値を関数にした場合
var a = function () {
  return {
    propA: function () { console.log(&amp;quot;A&amp;quot;); },
    propB: function () { console.log(&amp;quot;B&amp;quot;); },
  }
}();

a.propA(); //&amp;quot;A&amp;quot;
a.propB(); //&amp;quot;B&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;クロージャ&#34;&gt;クロージャ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;関数内部で定義した関数を、代入した変数（オブジェクト）では、中の変数の値も保持し続ける。&lt;/li&gt;
&lt;li&gt;この変数値も保持し続ける関数をクロージャと呼ぶ。プライベート変数みたいなものらしい。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var module = function() {
  var count = 0; //module関数の中で保持される変数（クロージャ）

  return {
    increment: function() {
      count++;
    },
    show: function() {
      console.log(count);
    }
  };

}();

module.show(); // 0
module.increment(); // countを+1する
module.show(); // 1
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;オブジェクト&#34;&gt;オブジェクト&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/yoshi389111/items/245df2d642e49d2acf3a&#34;&gt;参考:[JavaScript] オブジェクトの基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaScriptにおけるオブジェクトは、&lt;code&gt;{key: value}&lt;/code&gt;形式の入れ物（他言語の場合はハッシュテーブルとか連想配列というらしい）で関数も配列もオブジェクト。&lt;/li&gt;
&lt;li&gt;オブジェクトを生成してkey:valueを登録する場合は下記のように行える。&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;var obj = new Object();

// &amp;quot;hoge&amp;quot; というkeyに &amp;quot;hello&amp;quot; というvalueを登録
obj.hoge = &amp;quot;hello&amp;quot;;

// &amp;quot;func&amp;quot; というkeyに &amp;quot;world&amp;quot; という関数（オブジェクト）を登録
obj.func = function() {
  console.log(&amp;quot;world&amp;quot;;)
}

// ドット演算子
console.log(obj.hoge); // &amp;quot;hello&amp;quot;
obj.func(); // &amp;quot;world&amp;quot;

// 連想配列風にもアクセス可能
console.log(obj[&amp;quot;hoge&amp;quot;]); // &amp;quot;hello&amp;quot;
obj.[&amp;quot;func&amp;quot;](); // &amp;quot;world&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;valueが関数の場合は&lt;code&gt;メソッド&lt;/code&gt;と呼び、それ以外のオブジェクトの場合は&lt;code&gt;プロパティ&lt;/code&gt;と呼ぶ。&lt;/li&gt;

&lt;li&gt;&lt;p&gt;配列もオブジェクトだけど、特別なプロパティ・メソッドが存在している（&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array&#34;&gt;必要な時にggる&lt;/a&gt;）&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;ちなみにオブジェクトはオブジェクトリテラルで作成する事も可能&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;{}&lt;/code&gt;は&lt;code&gt;new Object()&lt;/code&gt;シンタックスシュガー（糖衣構文）&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;// new演算子でオブジェクトを作成した例
var obj = new Object();
obj.name = &amp;quot;Taro&amp;quot;;

// リテラルでオブジェクトを作成した場合
var obj = {name: &amp;quot;Taro&amp;quot;};
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;インスタンスとコンストラクタ&#34;&gt;インスタンスとコンストラクタ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;コンストラクタは関数オブジェクトで、インスタンスはコンストラクタを元に作成された空のオブジェクトの事。&lt;/li&gt;
&lt;li&gt;関数オブジェクト（コンストラクタ）を元に新しいオブジェクトを初期化して作成（インスタンス化）すると空のオブジェクト（インスタンス）ができる。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/takeharu/items/010752b1427773558f7c&#34;&gt;参考:JavaScriptのクラス？コンストラクタ？？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://uxmilk.jp/30348&#34;&gt;参考:JavaScriptのコンストラクタによるインスタンス生成&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;//空のコンストラクタを定義
var Animal = function(){};

//コンストラクタから空のインスタンスを生成
var dog = new Animal();
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;//コンストラクタを定義
function Animal = function(name,cry){
  this.name = name;
  this.bark = function() {
    console.log(cry);
  };
};

//コンストラクタから空のインスタンスを生成
var dog = new Animal(&#39;ポチ&#39;, &#39;ワン&#39;);
console.log(dog.name); // &amp;quot;ポチ&amp;quot;
dog.bark(); // ワン

var cat = new Animal(&#39;タマ&#39;,&#39;にゃー&#39;);
console.log(cat.name); // &amp;quot;タマ&amp;quot;
cat.bark(); // &amp;quot;にゃー&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;プロトタイプ&#34;&gt;プロトタイプ&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;コンストラクタを定義すると、コンストラクタごとに関連付けられた&lt;strong&gt;「プロトタイプオブジェクト」&lt;/strong&gt;が暗黙的に作成される。&lt;/li&gt;
&lt;li&gt;同じコンストラクタから生成されたインスタンスは、プロトタイプオブジェクトを共有する。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://javascript.keicode.com/lang/prototypes.php&#34;&gt;参考:JavaScript入門 | プロトタイプとは？&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/howdy39/items/35729490b024ca295d6c&#34;&gt;参考:図で理解するJavaScriptのプロトタイプチェーン&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-JavaScript&#34;&gt;//コンストラクタを定義
function Animal = function(name){
  this.name = name;
};

var dog = new Animal(&#39;ポチ&#39;);
var cat = new Animal(&#39;タマ&#39;);

if (dog === cat) {
  // false
}

if (dog.prototype === cat.prototype) {
  // true
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;よく使われる謎コード&#34;&gt;よく使われる謎コード&lt;/h5&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.f-sp.com/entry/2016/11/18/190732&#34;&gt;参考:JavaScriptの謎コードまとめ&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;!!x&lt;/code&gt; - 二重論理否定の意。二重論理否定には任意の型をBoolean型に変換する副作用がある。Boolean型のへの変更。よく使うらしい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x||0&lt;/code&gt; - 論理和の意。左辺値をBoolean型として評価して、trueなら左辺値。falseなら右辺値を評価値とする。左か右のどちらかがそのまま返ってくる。よく使うらしい。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2018/05 - Thaad week I Learned</title>
      <link>https://kglabo.com/blog/til-201805-thaad-week/</link>
      <pubDate>Fri, 25 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201805-thaad-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!-- tags = [ &#34;slackbot&#34;, &#34;MD5&#34;, &#34;SHA256&#34;, &#34;Atomic Design&#34;, &#34;Linuxコマンド&#34;,&#34;Storybook&#34;, &#34;npx&#34;, &#34;webpack&#34; &#34;require&#34;] --&gt;

&lt;h2 id=&#34;2018-05-21-learned&#34;&gt;2018/05/21 - Learned&lt;/h2&gt;

&lt;p&gt;5月21日（月）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;slackbotについて&#34;&gt;SlackBotについて&lt;/h3&gt;

&lt;p&gt;SlackBotを作る際に利用するSlack API Tokenには種類がある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Slackのほぼすべての機能を使えるレガシートークン

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/ykhirao/items/0d6b9f4a0cc626884dbb&#34;&gt;Slack APIのTokenの取得・場所&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;流出した場合は、チャンネルの削除から何からやり放題。必要な機能にしかアクセス権を与えないトークン&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/ykhirao/items/3b19ee6a1458cfb4ba21&#34;&gt;Slack API 推奨Tokenについて - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;流出しても必要最低限の権限しか与えられていない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;暗号化について&#34;&gt;暗号化について&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;MD5よりSHA256のほうが安全らしい

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/t-mochizuki/items/5ab21b6ae9b1941122ab&#34;&gt;md5とsha256を使ってみた - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-22-learned&#34;&gt;2018/05/22 - Learned&lt;/h2&gt;

&lt;p&gt;5月22日（火）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;atomic-designについて&#34;&gt;Atomic Designについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;パーツ・コンポーネント単位で定義していく UI デザイン手法。&lt;/li&gt;
&lt;li&gt;アプローチ / 考え方

&lt;ul&gt;
&lt;li&gt;エディトリアル / グラフィックからではなく、マークアップ / コーディングからUI設計を行っていく手法で、メリットとしてUIが一定の品質でテンプレ化される事によって、非デザイナーでも一定水準の品質のプロダクトデザインを担保する事が可能。&lt;/li&gt;
&lt;li&gt;参考 : &lt;a href=&#34;http://design.dena.com/design/atomic-design-%E3%82%92%E5%88%86%E3%81%8B%E3%81%A3%E3%81%9F%E3%81%A4%E3%82%82%E3%82%8A%E3%81%AB%E3%81%AA%E3%82%8B/&#34;&gt;Atomic Design を 分かったつもりになる&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;# 構成要素
- atoms / 原子（あとむす）
  - UI部品の最小単位
- molecules / 分子（もれきゅーる）
  - 機能的なまとまり
- organisms / 生体（おーがにずむす）
  - ページ内のセクション
- templates / テンプレート（てんぷれーと）
  - ワイヤーフレームとなるもの
- pages / ページ
  - テンプレートに内容を入れた、実際表示される状態
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;考え方としてはBootstrapに近い。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-23-learned&#34;&gt;2018/05/23 - Learned&lt;/h2&gt;

&lt;p&gt;5月23日（水）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;next-jsについて&#34;&gt;Next.jsについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;とても楽に React の web application を開発する事が可能。

&lt;ul&gt;
&lt;li&gt;ReactをSSR（Server Side Rendering）し、Babelで書くことが出来、buildもしてくれつつ、Universal JavaScript Web Applicationを作成する事ができるOSSのWeb Framework。&lt;/li&gt;
&lt;li&gt;Reactの学習をした後、Next.jsを使えばShadow DOMの修学は問題ない&lt;/li&gt;
&lt;li&gt;仕様が明確で拡張性も高い。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-24-learned&#34;&gt;2018/05/24 - Learned&lt;/h2&gt;

&lt;p&gt;5月24日（木）のToday I Leaned&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;金沢の最高気温は19/7度、最低気温は16.7度。&lt;/li&gt;
&lt;li&gt;体調不良にてしんでおりました。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-25-learned&#34;&gt;2018/05/25 - Learned&lt;/h2&gt;

&lt;p&gt;5月25日（金）のToday I Leaned&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;1.5hほどもくもくする時間を確保。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;linuxコマンドについて&#34;&gt;Linuxコマンドについて&lt;/h3&gt;

&lt;h4 id=&#34;mkdir&#34;&gt;mkdir&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;mkdir hoge fuga&lt;/code&gt; で 複数ディレクトリを同時作成する事が可能&lt;/li&gt;
&lt;li&gt;&lt;code&gt;mkdir -p hoge/fuga piyo/foo&lt;/code&gt; で多階層ディレクトリを作成する事が可能&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;touch&#34;&gt;touch&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;touch&lt;/code&gt; コマンド自体は指定したファイルのタイムスタンプを変更するコマンド。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch -t [[CC]YY]MMDDhhmm[.ss]&lt;/code&gt; で指定したタイムスタンプに変更できる。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touch hoge&lt;/code&gt; でファイルが存在していない場合は0サイズのファイルを作成する事ができる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;pdcopy&#34;&gt;pdcopy&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;pdcoby&lt;/code&gt; で、ターミナルの出力をクリップボードにコピーしてくれる

&lt;ul&gt;
&lt;li&gt;入力を終える場合は&lt;code&gt;Ctrl +D&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;cat ~/.ssh/id_rsa.pub | pbcopy&lt;/code&gt; とかで利用すると便利。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;storybookについて&#34;&gt;Storybookについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;React / Raact Native / Vue向けのUI開発環境。&lt;/li&gt;
&lt;li&gt;サンドボックス環境を構築してコンポーネントの挙動やコンポーネントを一望できる&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;使いみち&#34;&gt;使いみち&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;自作コンポーネントのライブラリー（一覧）や状態込みのスタイルガイド&lt;/li&gt;
&lt;li&gt;ページの作成中、適切なコンポーネントを素早く選び出す&lt;/li&gt;
&lt;li&gt;開発中・開発後にコンポーネントの UI をテストする&lt;/li&gt;
&lt;li&gt;コンポーネントや API のドキュメント&lt;/li&gt;
&lt;li&gt;エンジニアやデザイナー間のコミュニケーション&lt;/li&gt;
&lt;li&gt;アプリケーションの仕様書&lt;/li&gt;
&lt;li&gt;参考 : &lt;a href=&#34;https://storybook.js.org/examples/&#34;&gt;https://storybook.js.org/examples/&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;npxについて&#34;&gt;npxについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Node.jsを8.2.0以上にアップデートすると利用する事が可能。&lt;/li&gt;
&lt;li&gt;できる事

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;npm i&lt;/code&gt; で インストールしたパッケージを &lt;code&gt;npx {パッケージ名}&lt;/code&gt; で実行する事が可能。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;これまでの実行方法

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;./node_modules/.bin/(パッケージ名)&lt;/code&gt; で実行&lt;/li&gt;
&lt;li&gt;&lt;code&gt;$(npm bin)/(パッケージ名)&lt;/code&gt; で実行&lt;/li&gt;
&lt;li&gt;package.jsonにnpm-scriptを記述して実行&lt;/li&gt;
&lt;/ol&gt;&lt;/li&gt;
&lt;li&gt;おまけ

&lt;ul&gt;
&lt;li&gt;ローカルにインストールしていないパッケージを&lt;code&gt;npx {パッケージ名}&lt;/code&gt; で実行する事が可能（↓こんなかんじ）&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;$ npx cowsay nyarnしか書けねえ体にしてやろうか！

npx: 10個のパッケージを2.106秒でインストールしました。
 _____________________________________
&amp;lt; nyarnしか書けねえ体にしてやろうか！ &amp;gt;
 -------------------------------------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;webpackについて&#34;&gt;Webpackについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;モジュールバンドラーとは、モジュールをひとまとめにするツールであり、JSのモジュール各種をまとめて依存関係を解決してひとつのファイルにしてくれるツール。&lt;/li&gt;
&lt;li&gt;もともとはNode.jsの&lt;code&gt;require()&lt;/code&gt;というモジュール読み込みの仕組み。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;entry&#34;&gt;Entry&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;読み込みを行うモジュールの 依存関係を解決する為のエントリポイント&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;output&#34;&gt;Output&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;バンドルされたファイルのアウトプット先。&lt;/li&gt;
&lt;li&gt;出力先は絶対パスじゃないとだめ。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;requireの歴史&#34;&gt;requireの歴史&lt;/h3&gt;

&lt;h4 id=&#34;commonjs&#34;&gt;CommonJS&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;JS便利だからブラウザ以外でも使おうぜ。サーバサイドとか。&lt;/li&gt;
&lt;li&gt;でもブラウザ上で動かす為のものだから動かないよね。&lt;/li&gt;
&lt;li&gt;困るから、ServerSideの標準仕様を定めようぜ → commonJS&lt;/li&gt;
&lt;li&gt;外部ライブラリの参照は各JSをモジュール化して、&lt;code&gt;require()&lt;/code&gt;で読み込みしよう → commonJSの仕様として出てきた。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;node-js&#34;&gt;Node.js&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;サーバサイドでJSを利用できるようにしたもの。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;require()&lt;/code&gt; は独自拡張されたらしい。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;npm install&lt;/code&gt; したパッケージは &lt;code&gt;require()&lt;/code&gt; で読み込む事が可能。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;requirejs&#34;&gt;RequireJS&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;クライアントサイドでも&lt;code&gt;reauire()&lt;/code&gt;を使う為に作られたライブラリ。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;webpack&#34;&gt;WebPack&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;RequireJSをもっと強くしたもの。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;reauire()&lt;/code&gt; の対象範囲をJSのモジュールだけではなく、

&lt;ul&gt;
&lt;li&gt;altJSのコンパイル&lt;/li&gt;
&lt;li&gt;CSS / HTMLファイル取り込み&lt;/li&gt;
&lt;li&gt;JSファイルの取り込み&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;参考  : &lt;a href=&#34;https://qiita.com/uryyyyyyy/items/b10b012703b5396ded5a&#34;&gt;require()とは何か？何が便利なのか - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>2018/05 - Second week I Learned</title>
      <link>https://kglabo.com/blog/til-201805-second-week/</link>
      <pubDate>Fri, 18 May 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-201805-second-week/</guid>
      <description>

&lt;h1 id=&#34;今週-知った-学んだこと&#34;&gt;今週、知った/学んだこと&lt;/h1&gt;

&lt;!--tags = [ “git”, “submodule”, “CLI”, ”npx”, “名刺”, “回線速度” ]--&gt;

&lt;h2 id=&#34;2018-05-14-learned&#34;&gt;2018/05/14 - Learned&lt;/h2&gt;

&lt;p&gt;5月14日（月）のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;gitについて&#34;&gt;Gitについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;git push origin HEAD&lt;/code&gt; で、pushした場合は毎回、現在のCurrent branch　でpushする事ができる。

&lt;ul&gt;
&lt;li&gt;毎回、&lt;code&gt;git push origin feature/HOGEHOGE/FUGAFUGA-1001&lt;/code&gt; みたいなの入力してたのでかなり楽になって良い。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;gitconfigで指定されているuser.name等がgitに記録されるタイミングは &lt;code&gt;git commit&lt;/code&gt;をしたタイミング。

&lt;ul&gt;
&lt;li&gt;違うユーザアカウントでpushしてしまった為、gittconfigを書き換えて治そうとしたが、再度commitしないと治らなかった為、判明。&lt;/li&gt;
&lt;li&gt;個人のuser.nameで業務リポジトリにpushされてちょっと恥ずかしかった。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-15-learned&#34;&gt;2018/05/15 - Learned&lt;/h2&gt;

&lt;p&gt;5月15（火）日のToday I Leaned。&lt;/p&gt;

&lt;h3 id=&#34;gitについて-1&#34;&gt;Gitについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ブログのテーマがsubmodule化されているが、毎回読み込みの仕方を忘れる

&lt;ul&gt;
&lt;li&gt;gitのsubmoduleは、メインのリポジトリで&lt;code&gt;git submodule update -i&lt;/code&gt;とすると、submoduleの取り込みを行う。&lt;/li&gt;
&lt;li&gt;git submodule foreach git pull origin master` で最新のsubmodule側のリポジトリの状態に更新してくれる&lt;/li&gt;
&lt;li&gt;尚、上記コマンドを入力する所は、メインのリポジトリのrootで大゛勝負な模様。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-16-learnded&#34;&gt;2018/05/16 - Learnded&lt;/h2&gt;

&lt;p&gt;5月16（水）日のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;回線速度調査の手法&#34;&gt;回線速度調査の手法&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;CLIから回線速度のテストが出来るようにするfast-cliというものがあるらしい。

&lt;ul&gt;
&lt;li&gt;Nodeで動くので &lt;code&gt;npm install --global fast-cli&lt;/code&gt;でインストールしたら、fastコマンドで動作するようになる。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/suin/items/8398f0b07299a3cc194f&#34;&gt;参考 : 回線速度のテストができる「fast」コマンドが便利だった - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;CLIでnpxを活用して自己紹介をする方法があった。

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://qiita.com/akameco/items/e0af9e3cdf1cdb6fca61&#34;&gt;名刺の代わりにCLIアプリを書く - Qiita&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-17-learnded&#34;&gt;2018/05/17 - Learnded&lt;/h2&gt;

&lt;p&gt;5月17（木）日のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;知識メモ&#34;&gt;知識メモ&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ハインリッヒの法則というものがある。

&lt;ul&gt;
&lt;li&gt;内容としては、 1つの重大事故の背後には29の軽微な事故があり、その背景には300の異常が存在するというもの。&lt;/li&gt;
&lt;li&gt;つまり、重大な事故がX件ある場合は、29倍の軽微な事故・災害があって、300倍のヒヤリ・ハットがあるという事。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;セキュリティ対策&#34;&gt;セキュリティ対策&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;セキュリティ対策は重要だという話。

&lt;ul&gt;
&lt;li&gt;ハッカーは脆弱性の隙間を突いて、最終的にサーバのrootをハッキングする為の行動を取る。&lt;/li&gt;
&lt;li&gt;Ubuntu + Drupal構成のサーバがあった場合は、&lt;/li&gt;
&lt;li&gt;利用しているポートを確認。&lt;/li&gt;
&lt;li&gt;Drupalのバージョン確認 → 脆弱性を確認してアタック&lt;/li&gt;
&lt;li&gt;Drupalのアカウントを作成&lt;/li&gt;
&lt;li&gt;Drupal上でPHPを実行可能にするPluginを導入&lt;/li&gt;
&lt;li&gt;phpinfoでサーバ情報を取得 → サーバのバージョンを確認&lt;/li&gt;
&lt;li&gt;サーバの脆弱性をアタックしてrootユーザのパスワードを取得&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;2018-05-18-learnded&#34;&gt;2018/05/18 - Learnded&lt;/h2&gt;

&lt;p&gt;5月18（木）日のToday I Leaned&lt;/p&gt;

&lt;h3 id=&#34;ユーザテストについて&#34;&gt;ユーザテストについて&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ここ数日、某サービスのユーザテストの被験者として体験して思った事。&lt;/li&gt;
&lt;li&gt;サービス利用に至った背景や、テスト開始時点での状況説明を適切に行う必要がある。&lt;/li&gt;
&lt;li&gt;その説明を怠ると、そもそも把握している前提条件の元でテストを行っているつもりが、違う所で躓いてしまって求める問いと異なるテスト結果になりそうな為。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TIL - ReactStudy#02</title>
      <link>https://kglabo.com/blog/react-study-02/</link>
      <pubDate>Wed, 28 Mar 2018 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/react-study-02/</guid>
      <description>

&lt;h2 id=&#34;やった事&#34;&gt;やった事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;create-react-app

&lt;ul&gt;
&lt;li&gt;テンプレ作成&lt;/li&gt;
&lt;li&gt;テンプレ編集&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Babel

&lt;ul&gt;
&lt;li&gt;es2015からの変換(トランスパイル)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;必要なパッケージのインストール

&lt;ul&gt;
&lt;li&gt;babel-cli&lt;/li&gt;
&lt;li&gt;babel-preset-env&lt;/li&gt;
&lt;li&gt;babel-preset-react&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;わかった事&#34;&gt;わかった事&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Babel使うとコードの記述がものすごい楽。&lt;/li&gt;
&lt;li&gt;JSX使わなくてもReactは書けるけど、クソ面倒くさいから使ったほうが楽。というか普通は使う。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;次にやること&#34;&gt;次にやること&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ReactでComponentを作成する&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;備考&#34;&gt;備考&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;babel-preset-env&lt;/code&gt;がECMAScriptのサポート環境に応じたプラグインを設定するプリセットパッケージ。という説明だったがあんまりピンと来てないのでそのうち調べる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;リポジトリ&#34;&gt;リポジトリ&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yu-kgr/learn-react-app&#34;&gt;yu-kgr/learn-react-app&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/yu-kgr/learn-react-app/commit/eb59019dd89bae478e4db7494b6adff278ec66f2&#34;&gt;該当コミットログ&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TIL - JavaScript - DOMオブジェクトについて</title>
      <link>https://kglabo.com/blog/javascript-study-01/</link>
      <pubDate>Thu, 30 Nov 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/javascript-study-01/</guid>
      <description>

&lt;h2 id=&#34;javascript-domオブジェクトについて&#34;&gt;JavaScript - DOMオブジェクトについて&lt;/h2&gt;

&lt;p&gt;JavaScriptでWebサイトを動的に書き換えるには、Document Object Model（DOM）という仕組みを利用する&lt;/p&gt;

&lt;h2 id=&#34;document-object-model-dom-とは&#34;&gt;Document Object Model（DOM）とは&lt;/h2&gt;

&lt;p&gt;JavaScriptで記述されたプログラムから、HTMLページにアクセスして、HTMLページを操作する方法を提供している。&lt;/p&gt;

&lt;h2 id=&#34;domツリー&#34;&gt;DOMツリー&lt;/h2&gt;

&lt;p&gt;DOMツリーとは、HTMLドキュメントやXMLドキュメントをツリー構造として表現したもの。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;head&amp;gt;
  &amp;lt;title&amp;gt;Document&amp;lt;/title&amp;gt;
&amp;lt;/head&amp;gt;
&amp;lt;body&amp;gt;
&amp;lt;h1&amp;gt;大見出し&amp;lt;/h1&amp;gt;
&amp;lt;h2&amp;gt;中見出し&amp;lt;/h2&amp;gt;
&amp;lt;p&amp;gt;DOMツリーとは、HTMLドキュメントやXMLドキュメントを&amp;lt;strong&amp;gt;ツリー構造&amp;lt;/strong&amp;gt;として表現したもの。&amp;lt;/p&amp;gt;
&amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Document

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;html&amp;gt;&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;head&amp;gt;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;title&amp;gt;&lt;/code&gt; - Document&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;body&amp;gt;&lt;/code&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;h1&amp;gt;&lt;/code&gt; - 見出し&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;h2&amp;gt;&lt;/code&gt; - 見出し&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;p&amp;gt;&lt;/code&gt; - DOMツリーとは、HTMLドキュメントやXMLドキュメントをツリー構造として表現したもの。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;&amp;lt;strong&amp;gt;&lt;/code&gt; - ツリー構造&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ノード&#34;&gt;ノード&lt;/h2&gt;

&lt;p&gt;文章を構成する要素、属性、テキストといったオブジェクトをノードと呼ぶ。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;要素ノード&lt;/li&gt;
&lt;li&gt;属性ノード&lt;/li&gt;
&lt;li&gt;テキストノード&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;dom仕様策定について&#34;&gt;DOM仕様策定について&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;DOMの仕様は、Level1~4がW3Cにより策定。

&lt;ul&gt;
&lt;li&gt;W3Cとは、WEBで使用される各種技術の標準化を推進する為に設立された団体。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;最新版は、WHATWG（Web Hypertext Application Technology Working Group）というコミュニティーがLiving Standardとして定義。

&lt;ul&gt;
&lt;li&gt;Living Standardとは常に改良が加えられているゆるい規格のようなもの。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;ブラウザオブジェクトの階層構造&#34;&gt;ブラウザオブジェクトの階層構造&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;window

&lt;ul&gt;
&lt;li&gt;screen&lt;/li&gt;
&lt;li&gt;document&lt;/li&gt;
&lt;li&gt;location&lt;/li&gt;
&lt;li&gt;form

&lt;ul&gt;
&lt;li&gt;Element&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;anchor&lt;/li&gt;
&lt;li&gt;Images&lt;/li&gt;
&lt;li&gt;navigator&lt;/li&gt;
&lt;li&gt;history&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;window-オブジェクト&#34;&gt;window オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ブラウザを操作するための機能を集めたオブジェクト&lt;/li&gt;
&lt;li&gt;ブラウザオブジェクトの階層構造の最上位に位置する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;document-オブジェクト&#34;&gt;document オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Windowオブジェクト内に表示された、HTMLで表現されているコンテンツを保持しているオブジェクト&lt;/li&gt;
&lt;li&gt;Window内に表示されたドキュメントを操作するのは、Documentオブジェクトの役割。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;location-オブジェクト&#34;&gt;Location オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;現在表示されているページのロケーションに関する情報を提供する&lt;/li&gt;
&lt;li&gt;現在の表示URLアドレスに関する情報を取得できる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;history-オブジェクト&#34;&gt;history オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ブラウザの履歴の操作&lt;/li&gt;
&lt;li&gt;画面上に表示しているページの移動などの操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;navigator-オブジェクト&#34;&gt;Navigator オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ブラウザ名やバージョンなど、ブラウザ固有の情報を提供する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;screen-オブジェクト&#34;&gt;screen オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ディスプレイに関する情報を提供する&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;form-オブジェクト&#34;&gt;form オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Formに関する情報を提供&lt;/li&gt;
&lt;li&gt;Formの操作&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;anchor-オブジェクト&#34;&gt;Anchor オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;ページ上のアンカー（&lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt;）に関する情報を取得できる&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;images-オブジェクト&#34;&gt;Images オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;画像に関する情報の提供&lt;/li&gt;
&lt;li&gt;画像を操作する機能の提供&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;elements-オブジェクト&#34;&gt;Elements オブジェクト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;HTMLドキュメントやXMLドキュメントにおける、要素（タグ）の事&lt;/li&gt;
&lt;li&gt;例&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code class=&#34;language-html&#34;&gt;&amp;lt;p&amp;gt;hogefuga&amp;lt;/p&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>TIL - UX研修 - 他社UI調査/インタビュー設計</title>
      <link>https://kglabo.com/blog/til-user-experience-training-02/</link>
      <pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-user-experience-training-02/</guid>
      <description>

&lt;h2 id=&#34;なにこれ&#34;&gt;なにこれ&lt;/h2&gt;

&lt;p&gt;社内でのUX研修で学んだ事のメモ&lt;/p&gt;

&lt;h2 id=&#34;研修内容&#34;&gt;研修内容&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;他社UI調査&lt;/li&gt;
&lt;li&gt;インタビュー設計&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;問いを立てる&#34;&gt;問いを立てる&lt;/h2&gt;

&lt;p&gt;実際に競合他社と比較して問いを立てる（20分）&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;こうだと思うけど（仮説）&lt;/li&gt;
&lt;li&gt;こうなっているのは（現実）&lt;/li&gt;
&lt;li&gt;なぜだろう（問い）&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;仮説ではなく問いを立てる&#34;&gt;仮説ではなく問いを立てる&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;仮説では質問者の考え（バイアス）が掛かるため、純粋に知りたい問いを探す&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;定量調査と定性調査&#34;&gt;定量調査と定性調査&lt;/h2&gt;

&lt;h3 id=&#34;定量調査&#34;&gt;定量調査&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ログ重視/結果重視&lt;/li&gt;
&lt;li&gt;広く浅い情報を取り扱う&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;定性調査&#34;&gt;定性調査&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ログ化されていない情報の収集&lt;/li&gt;
&lt;li&gt;新しい価値の発見/狭く深い情報を取り扱う&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;定量調査と定性調査の組み合わせが大事&#34;&gt;定量調査と定性調査の組み合わせが大事&lt;/h4&gt;

&lt;p&gt;現状何が起きているのかを定量調査で確認して、&lt;br /&gt;
定性調査でどうしてそうなっているのかプロセスを確認して行って施策の成果を定量調査で確認する。&lt;/p&gt;

&lt;h4 id=&#34;定性調査の種類&#34;&gt;定性調査の種類&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;エスノグラフィ

&lt;ul&gt;
&lt;li&gt;被験者の実際の利用現場に赴きも場合によっては調査者自身も被験者と一体となり調査する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;コンテクスチュアルインクワイアリー

&lt;ul&gt;
&lt;li&gt;被験者が自分の行動や思いを説明しながら、サービスやプロダクトを普段通りに利用してもらう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;オブザベーション

&lt;ul&gt;
&lt;li&gt;調査側が用意した手順に沿ってサービスやプロダクトを利用してもらい、観察をする&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;インタビュー

&lt;ul&gt;
&lt;li&gt;双方向のやり取りを交えて、被験者に話を聞く&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;アンケート

&lt;ul&gt;
&lt;li&gt;一方的に示した問に対して、情報を収集する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;インタビューの種類&#34;&gt;インタビューの種類&lt;/h4&gt;

&lt;p&gt;今回はインタビューについて深掘り・学習する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;非構造化インタビュー

&lt;ul&gt;
&lt;li&gt;事前に設問を決めずに、その場に合わせて質問する。予想だにしてなかった発見があるが、時間がかかる。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;半構造化インタビュー

&lt;ul&gt;
&lt;li&gt;事前に決めた設問に沿って進めつつ、必要な箇所は深掘りをしていく。時間的に効率よく進められ深掘りもできるが、バイアスがかかる懸念。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;構造化インタビュー

&lt;ul&gt;
&lt;li&gt;事前に決めておいた設問のみ質問する。短時間で終わるが深掘りができない。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&#34;インタビュー設計&#34;&gt;インタビュー設計&lt;/h2&gt;

&lt;p&gt;インタビューをどうやって行うかの設計。&lt;/p&gt;

&lt;h2 id=&#34;調査の目的を明らかにする&#34;&gt;調査の目的を明らかにする&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;調査で、何を明らかにしたいのかを決める&lt;/li&gt;
&lt;li&gt;調査結果を何に、どのように使うのかを決める&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;被験者集め-リクルーティング&#34;&gt;被験者集め（リクルーティング）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;被験者の条件を決定&lt;/li&gt;
&lt;li&gt;話を聞くべき人の条件を洗い出す ※複数のセグメントを設定することもできる&lt;/li&gt;
&lt;li&gt;被験者の数を決定

&lt;ul&gt;
&lt;li&gt;最低でも３人、一般的には５人&lt;/li&gt;
&lt;li&gt;※ただしセグメントごとにこの人数が必要&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;被験者候補の抽出

&lt;ul&gt;
&lt;li&gt;人づて（知り合い、知り合いの知り合い）&lt;/li&gt;
&lt;li&gt;スクリーニングアンケート&lt;/li&gt;
&lt;li&gt;外部の調査会社に依頼&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;実査の調整

&lt;ul&gt;
&lt;li&gt;セグメントと照合しているか直接確認&lt;/li&gt;
&lt;li&gt;日程調整&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;インタビュー設計-1&#34;&gt;インタビュー設計&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;ラポールの形成

&lt;ul&gt;
&lt;li&gt;リラックスしてもらい、本音を言いやすい空気を作る ※挨拶の応答や雑談で会話をし、被験者にも声を出してもらう&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;インフォームドコンセント

&lt;ul&gt;
&lt;li&gt;安心して意見を言えるように、調査について伝える ※調査目的、個人情報の取り扱い、任意参加である点などを伝える&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;基本情報の質問

&lt;ul&gt;
&lt;li&gt;本題に入る前に、周辺状況や利用の背景について質問する&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;本題の質問&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;本題の質問&#34;&gt;本題の質問&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;インタビュー内容の設計手順

&lt;ul&gt;
&lt;li&gt;知りたいことを答えてもらえる質問にする&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;ol&gt;
&lt;li&gt;明らかにしたいことを洗い出す&lt;/li&gt;
&lt;li&gt;明らかにしたいことを精査し優先度をつけ、高いものをピックアップする&lt;/li&gt;
&lt;li&gt;明らかにしたいことを知るために、何をどのように聞くべきかを検討する&lt;/li&gt;
&lt;li&gt;設問を並べ、答えが得られやすいような順番を検討する&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;インタビュー内容の設計tips&#34;&gt;インタビュー内容の設計TIPS&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;被験者が「はい / いいえ」で答えられない、回答が膨らむような質問にしましょう

&lt;ul&gt;
&lt;li&gt;はい、いいえで終わるとそれ以上の情報が得られません。被験者が自ら説明してくれるような質問が理想です。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;被験者が利用する状況や背景、理由などが明らかになる質問をしましょう

&lt;ul&gt;
&lt;li&gt;被験者の行為や結果だけではなく、なぜその結果に至ったのかという点が最も重要です。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;答えやすい質問を先に、答えにくい質問を後に回しましょう

&lt;ul&gt;
&lt;li&gt;被験者が話しやすい順序を工夫しましょう。場合によっては用意した順序を入れ替えてもかまいません。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;質問者の思い込みが入り、被験者の答えが偏るような質問はやめましょう

&lt;ul&gt;
&lt;li&gt;自分が持っている仮説を検証するような質問ではなく、被験者のありのままの情報を収集すると理解が深まります。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;情報が引き出せない場合、初めての利用や直近の利用を質問してみましょう

&lt;ul&gt;
&lt;li&gt;初めての利用や直近の利用は記憶に残りやすいです。足がかりとして被験者の情報を引き出すことができます。&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;インタビュー項目の設計&#34;&gt;インタビュー項目の設計&lt;/h2&gt;

&lt;p&gt;インタビュー項目の設計を実際に行う（20分）&lt;br /&gt;
設計する際の順番は、先に作成した問いに対して下記の事を意識して作成する。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;優先度をつける&lt;/li&gt;
&lt;li&gt;何をどのように聞くべきか検討する&lt;/li&gt;
&lt;li&gt;答えが得られやすいような順番を検討する&lt;/li&gt;
&lt;/ol&gt;

&lt;ul&gt;
&lt;li&gt;10分程度のインタビューだと適正数は3~4つの問い&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>TIL - エンジニアの稼働率と工数管理について</title>
      <link>https://kglabo.com/blog/til-man-hour-managa/</link>
      <pubDate>Thu, 13 Jul 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/til-man-hour-managa/</guid>
      <description>

&lt;h2 id=&#34;なにこれ&#34;&gt;なにこれ&lt;/h2&gt;

&lt;p&gt;主にウォーターフォール時に各タスクの工数を算出したり作業分解したタスクをどう割り振るのか考える時に役に立つであろう情報。&lt;/p&gt;

&lt;h2 id=&#34;稼働率&#34;&gt;稼働率&lt;/h2&gt;

&lt;p&gt;稼働率 is 働ける割合。&lt;/p&gt;

&lt;p&gt;稼働率は、1日あたり8時間となるので、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;8h ＝ 480min ＝ 100%&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;60min = 12.5%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;て、1hにつき &lt;code&gt;12.5%&lt;/code&gt; となる。&lt;/p&gt;

&lt;h3 id=&#34;例&#34;&gt;例&lt;/h3&gt;

&lt;p&gt;5時間掛かる作業の場合は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;12.5*5 = 62.5%&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;これを「何日かけて対応するか」で日数分で割る。&lt;br /&gt;
「何日かけて対応するか」はメンバーの空き稼働率の状況で判断する。&lt;/p&gt;

&lt;h2 id=&#34;役割毎の稼働率の違い&#34;&gt;役割毎の稼働率の違い&lt;/h2&gt;

&lt;p&gt;末端作業者と管理層では一日の作業に費やすことができる稼働率が異なる。&lt;br /&gt;
一般的には末端作業者は &lt;code&gt;70~80%&lt;/code&gt; が限度。&lt;/p&gt;

&lt;p&gt;例えば、会議や雑務の割合が多くて、&lt;br /&gt;
1日あたり4hは管理系業務で時間が取られている場合は、&lt;/p&gt;

&lt;p&gt;8hのうち、4hしか作業時間を確保できない為、&lt;br /&gt;
&lt;code&gt;8h - 4h = 4h&lt;/code&gt; で、作業割合 &lt;code&gt;50%（12.5 ✕ 4）&lt;/code&gt; が上限となる。&lt;/p&gt;

&lt;p&gt;管理者は自分自身の稼働率がどの程度なのか確認しておくと良い。&lt;/p&gt;

&lt;h2 id=&#34;補足&#34;&gt;補足&lt;/h2&gt;

&lt;p&gt;期間と作業割合がわかっているタスクに関しては、&lt;br /&gt;
逆算して初期見積入れておいても良い。
※ 単純にタスクに何時間かけるか分かるようになるだけだが‥&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>リポジトリにssh接続でgit cloneする為にssh-keygen -f hogehogeで、別名pubファイルを作ったら永遠にcloneできなかった話</title>
      <link>https://kglabo.com/blog/another-name-ssh-keygen/</link>
      <pubDate>Mon, 08 May 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/another-name-ssh-keygen/</guid>
      <description>

&lt;h2 id=&#34;発生した問題&#34;&gt;発生した問題&lt;/h2&gt;

&lt;p&gt;githubの既存リポジトリから、sshでgit cloneしたかったので、&lt;br /&gt;
&lt;a href=&#34;http://qiita.com/suthio/items/2760e4cff0e185fe2db9&#34;&gt;お前らのSSH Keysの作り方は間違っている&lt;/a&gt;を参考にして暗号強度を高めつつ、&lt;br /&gt;
&lt;code&gt;ssh-keygen -f github_id_rsa&lt;/code&gt; で別名のpubファイルを作成してcloneした所、&lt;br /&gt;
下記のようなエラーが発生した。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Warning: Permanently added the RSA host key for IP address &#39;***.***.***.**&#39; to the list of known hosts.
Permission denied (publickey).
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;対処方法&#34;&gt;対処方法&lt;/h2&gt;

&lt;p&gt;GitHub へのアクセス時に、 &lt;code&gt;~/.ssh/id_rsa&lt;/code&gt; や &lt;code&gt;~/.ssh/id_dsa&lt;/code&gt; ではなく、&lt;br /&gt;
別名で認証鍵を作成した場合は、 &lt;code&gt;~/.ssh/config&lt;/code&gt; ファイルを作成して、&lt;br /&gt;
下記設定を記述する必要がある。&lt;/p&gt;

&lt;p&gt;また、configファイルに関しては、Permissionを600にする必要がある。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# ~/.ssh/config

Host github.com
    IdentityFile ~/.ssh/github_id_rsa
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上記の設定を加える事で、無事問題なくcloneする事ができた。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TIL - スクラムマスターについての勉強</title>
      <link>https://kglabo.com/blog/scrum-master-study-01/</link>
      <pubDate>Fri, 24 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/scrum-master-study-01/</guid>
      <description>

&lt;h1 id=&#34;スクラムの基礎知識&#34;&gt;スクラムの基礎知識&lt;/h1&gt;

&lt;h2 id=&#34;なにこれ&#34;&gt;なにこれ？&lt;/h2&gt;

&lt;p&gt;Schooで「はじめてのスクラムマスター」という講座があったので、&lt;br /&gt;
そちらの講座での学習した内容の備忘録。&lt;/p&gt;

&lt;h2 id=&#34;前置き&#34;&gt;前置き&lt;/h2&gt;

&lt;p&gt;スクラムの生みの親、Jeff Sutherland と Ken Schwaberによるスクラムのガイドがある。&lt;br /&gt;
&lt;strong&gt;現在も更新されているので、スクラムに関わる機会がある方はかならず読むこと。&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://www.scrumguides.org/docs/scrumguide/v2016/2016-Scrum-Guide-Japanese.pdf&#34;&gt;スクラムガイド 2016（PDF）&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;スクラムの定義&#34;&gt;スクラムの定義&lt;/h2&gt;

&lt;h3 id=&#34;スクラムとは&#34;&gt;スクラムとは&lt;/h3&gt;

&lt;p&gt;スクラムとは &lt;em&gt;開発プロセスではなく問題に対応する為のフレームワーク&lt;/em&gt; であり、&lt;br /&gt;
価値の高いプロダクトやサービスを、&lt;br /&gt;
&lt;strong&gt;生産性高く、クリエイティブに届ける為のフレームワーク&lt;/strong&gt; です。&lt;/p&gt;

&lt;h3 id=&#34;スクラムの定義-1&#34;&gt;スクラムの定義&lt;/h3&gt;

&lt;p&gt;スクラムとは、以下の様なものである。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;軽量&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;理解が容易&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;習得は困難&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;スクラムを採用するべき開発プロセスモデル&#34;&gt;スクラムを採用するべき開発プロセスモデル&lt;/h2&gt;

&lt;p&gt;採用すべき対象としては、&lt;br /&gt;
今まで経験した内容で開発全体が安定しているものではなく、&lt;br /&gt;
今まで経験した事がなく、 &lt;em&gt;試行・検査・適応&lt;/em&gt; していくしかないものに対して有効。&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;複雑で変化があるようなものに対して最適&lt;/strong&gt; だと言われている。&lt;/p&gt;

&lt;h2 id=&#34;スクラムの理論と柱&#34;&gt;スクラムの理論と柱&lt;/h2&gt;

&lt;p&gt;スクラムの理論としては、
実際に経験していく事によって判断を繰り返し行う事になるので、&lt;br /&gt;
結果として知識が蓄積されて行き、リスクの予測ができるようになっていく。&lt;/p&gt;

&lt;h3 id=&#34;抑えるべき要点&#34;&gt;抑えるべき要点&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;実際の経験 - A&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;即知に基づく判断 - B&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;知識 - C&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;予測可能性の最適化 - D&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;リスクマネジメント - E&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;具体的な理論&#34;&gt;具体的な理論&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;経験に基づいて（A）、&lt;br /&gt;
わかったことに対して対処していき（B/C）、&lt;br /&gt;
リスクに対応できるように行く（D/E）&lt;/strong&gt;&lt;/p&gt;

&lt;h3 id=&#34;守るべき柱&#34;&gt;守るべき柱&lt;/h3&gt;

&lt;p&gt;スクラムを行う上で、大切な柱は以下の3点。&lt;/p&gt;

&lt;h4 id=&#34;透明性&#34;&gt;&lt;em&gt;透明性&lt;/em&gt;&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;コンセンサスをとって認識齟齬を起こさないようにする。&lt;/li&gt;
&lt;li&gt;物事に対して共通認識を持つ。&lt;/li&gt;
&lt;li&gt;達成すべきゴールを一致させる。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;検査&#34;&gt;&lt;em&gt;検査&lt;/em&gt;&lt;/h4&gt;

&lt;h4 id=&#34;適応&#34;&gt;&lt;em&gt;適応&lt;/em&gt;&lt;/h4&gt;

&lt;h2 id=&#34;スクラムのスプリント&#34;&gt;スクラムのスプリント&lt;/h2&gt;

&lt;p&gt;タイムボックスと呼ぶ。&lt;br /&gt;
開発の反復を行う期間を固定する。これがとても大事
ウォーターフォールはそのまま流れ作業を行う。&lt;/p&gt;

&lt;p&gt;一度決めたタイムボックスを仮に2週間で決めた場合は、
タイムボックス毎にフィードバックが出るのでメリットとして、&lt;br /&gt;
ユーザや発注者に対しての期待値をコントロールできる。&lt;/p&gt;

&lt;p&gt;開発にリズムができるので利害関係者に対して、&lt;br /&gt;
次のスプリントに結果が確認できるという結果が提供できる。&lt;br /&gt;
この事により、横槍が入りづらくなるメリットがある。&lt;/p&gt;

&lt;h2 id=&#34;スクラムのイベント&#34;&gt;スクラムのイベント&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;検査&lt;/li&gt;
&lt;li&gt;適用&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;何かを行って開発を進めていくにあたって、&lt;br /&gt;
状況を確認する為のチェックポイントを作る。&lt;/p&gt;

&lt;p&gt;うまくいっている所は引き続きやっていく。
何か問題が発生している場合は改善する。&lt;/p&gt;

&lt;p&gt;それを行う為の仕組みとして、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;スプリントプランニング&lt;/li&gt;
&lt;li&gt;デイリースクラム&lt;/li&gt;
&lt;li&gt;スプリントレビュー&lt;/li&gt;
&lt;li&gt;レトロスペクティブ（振り返り）&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;タイムボックスで回した作業にて成果物が出来る。&lt;/p&gt;

&lt;h3 id=&#34;1-スプリントプランニング-スプリント計画会議&#34;&gt;1.スプリントプランニング（スプリント計画会議）&lt;/h3&gt;

&lt;p&gt;期間が決められたプロジェクトにあたる為、計画を行う。
* 何を作るのか
* それによって今の価値のあるプロダクトがどう変わるのか？&lt;/p&gt;

&lt;p&gt;期間を固定する。&lt;/p&gt;

&lt;h3 id=&#34;2-デイリースクラム&#34;&gt;2.デイリースクラム&lt;/h3&gt;

&lt;h4 id=&#34;参加するロール&#34;&gt;参加するロール&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;毎日、会議を行う（朝会とも言う）&lt;/li&gt;
&lt;li&gt;開発チーム内で毎日行う作業。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;期間を固定する。&lt;/p&gt;

&lt;p&gt;スプリントのゴールに対して&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;昨日、何をしたのか。&lt;/li&gt;
&lt;li&gt;今日、何をするのか&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;デイリースクラム自体もタイムボックスに入っているので、15分で終わらせる。
開発は難しいので、2週間という計画を立ててもその通りになるとは限らないので、
軌道修正・調整の為にデイリースクラムを行う。
朝じゃなくてもいいが、毎日同じ時間に同じ場所で同じメンバーで行うのが良い。&lt;/p&gt;

&lt;h3 id=&#34;3-スプリントレビュー&#34;&gt;3. スプリントレビュー&lt;/h3&gt;

&lt;p&gt;どういった機能を作るのか？という所に対して、&lt;br /&gt;
ちゃんと機能を満たしているかどうかについて共有する。&lt;/p&gt;

&lt;h3 id=&#34;4-レトロスペクティブ-ふりかえり&#34;&gt;4. レトロスペクティブ（ふりかえり）&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;良かった事を共有して継続する&lt;/li&gt;
&lt;li&gt;悪かった事は改善点を考えて共有する&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;期間を固定する。&lt;/p&gt;

&lt;h2 id=&#34;スクラムチーム&#34;&gt;スクラムチーム&lt;/h2&gt;

&lt;p&gt;以下のロールの人員が集まって、スクラムチームと呼ぶ。&lt;/p&gt;

&lt;h3 id=&#34;ロール&#34;&gt;ロール&lt;/h3&gt;

&lt;p&gt;大前提として、下記のロールには上下関係はなく全員が同じ立場である。
注意点として、プロダクトオーナー・スクラムマスターが従来のマネージャーやリーダーが行うケースが行う場合が多く、&lt;/p&gt;

&lt;h4 id=&#34;スクラムマスター-sm-1名&#34;&gt;スクラムマスター（SM）- 1名&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;全体を俯瞰して、スクラムが逸脱していないか・横槍が入らないかを確認・調整する&lt;/li&gt;
&lt;li&gt;スクラムとはどういうやり方なのかを説明して理解してもらう&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;プロダクトオーナー-po-1名&#34;&gt;プロダクトオーナー（PO）- 1名&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;プロダクトバックログで何をどの優先度で作るのか？という事を決定する&lt;/li&gt;
&lt;li&gt;開発チームが成果を出して、プロダクトをリリースするまでの責務を追う&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;開発チーム-devterm-6-3名&#34;&gt;開発チーム（DevTerm） - 6±3名&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;スプリントの中で実際に開発を行う&lt;/li&gt;
&lt;li&gt;スプリントのプランニングにも関わり、実際に作業の見積もりを行う。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;スクラムチームの特徴として&lt;br /&gt;
&lt;em&gt;自己組織化チーム&lt;/em&gt; であり、&lt;br /&gt;
&lt;em&gt;機能横断的チーム&lt;/em&gt; である。&lt;/p&gt;

&lt;h3 id=&#34;自己組織化チームとは&#34;&gt;自己組織化チームとは&lt;/h3&gt;

&lt;p&gt;スクラムチームに関しては&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;やり方の問題を解決したり&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;うまくいくように立ち向かっていく事に関しては、外部の支援なしで行う自立したチーム&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;機能横断的チームとは&#34;&gt;機能横断的チームとは&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;開発に必要な全ての事が行えるチーム&lt;/em&gt; でいる事。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;データベースの専門家がいない為、データベースの機能が実装ができません。&lt;/li&gt;
&lt;li&gt;チーム内では実装できないので、他から専門家を借りてくる。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;というケースはNG。&lt;/p&gt;

&lt;p&gt;いろんなスキルセットのメンバーが色々な知恵を出して保管し合って、&lt;br /&gt;
&lt;strong&gt;チームの中だけで完結して物事を達成していくチーム&lt;/strong&gt; である事。&lt;/p&gt;

&lt;p&gt;ただし個々が、スペシャリストである必要はない。
大事なのはチームで保管し合う事。&lt;/p&gt;

&lt;h3 id=&#34;チームの人員について&#34;&gt;チームの人員について&lt;/h3&gt;

&lt;p&gt;開発チームはできるだけ、 6±3名が良い。&lt;/p&gt;

&lt;h4 id=&#34;理由&#34;&gt;理由&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;3人未満だと、相互作用がおきづらい。&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;9人を超えると自己組織的に動きづらい。&lt;/em&gt;
* 理由としては同じマインドじゃない方がいたり、MTGの予定をあわせるのが難しくなったりする為。&lt;/p&gt;

&lt;p&gt;人数が超える場合は、2つのチームに分ける等をしたほうが良い。&lt;/p&gt;

&lt;p&gt;期間を2週間（仮）と区切る事で、期待をコントロールできる。
* クライアント / ユーザ 次の二週間後にフィードバックがかえってくる。という信頼感につながる。&lt;/p&gt;

&lt;p&gt;手を動かす人が、自分で見積もる。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TIL - プロジェクトマネジメント研修 ~WBSについて~</title>
      <link>https://kglabo.com/blog/project-management-study-02/</link>
      <pubDate>Tue, 21 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/project-management-study-02/</guid>
      <description>

&lt;h2 id=&#34;なにこれ&#34;&gt;なにこれ？&lt;/h2&gt;

&lt;p&gt;社内で、 &lt;em&gt;プロジェクトマネジメント研修 ~WBS編~&lt;/em&gt; に参加してきた為、&lt;br /&gt;
そちらの内容に関してのメモと、個人的に学習した内容を合わせた備忘録。&lt;/p&gt;

&lt;h2 id=&#34;wbsとは&#34;&gt;WBSとは&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;Work Breakdown Structure&lt;/em&gt; の略で、&lt;br /&gt;
プロジェクトマネジメントで計画を立てる際に用いられる手法の一つ。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;自転車の開発&lt;/em&gt; で例えると&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;デザイン&lt;/li&gt;
&lt;li&gt;車体作成

&lt;ul&gt;
&lt;li&gt;フレーム

&lt;ul&gt;
&lt;li&gt;部品制作&lt;/li&gt;
&lt;li&gt;組み立て&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;サドル

&lt;ul&gt;
&lt;li&gt;部品制作&lt;/li&gt;
&lt;li&gt;組み立て&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ペダルとギア

&lt;ul&gt;
&lt;li&gt;部品制作&lt;/li&gt;
&lt;li&gt;組み立て&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ハンドル

&lt;ul&gt;
&lt;li&gt;部品制作&lt;/li&gt;
&lt;li&gt;組み立て&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;上記のように作業に必要な工程を&lt;em&gt;要素分解&lt;/em&gt; する事で、&lt;br /&gt;
&lt;strong&gt;プロジェクト全体で必要な作業を把握出来るようにする手法&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;このように要素分解を行う事で、&lt;br /&gt;
各作業に必要な人員の確保・リソースの計算を行う事ができるようになる為、&lt;br /&gt;
&lt;em&gt;責任分担が明確化される&lt;/em&gt; 。&lt;/p&gt;

&lt;h2 id=&#34;wbs作成時のポイント&#34;&gt;WBS作成時のポイント&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;作業内容がもれなく記載されている事&lt;/li&gt;
&lt;li&gt;作業単位が適正に分解されて、分かりやすくなっている事&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;分割する際の軸&#34;&gt;分割する際の軸&lt;/h3&gt;

&lt;p&gt;WEBプロジェクトで主に使いそうなものは以下の3種類が多い。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;成果物&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;時系列&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;場所(担当)&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;成果物-を軸とした場合&#34;&gt;&lt;em&gt;成果物&lt;/em&gt; を軸とした場合&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;仕様&lt;/li&gt;
&lt;li&gt;デザイン&lt;/li&gt;
&lt;li&gt;システム&lt;/li&gt;
&lt;li&gt;プロジェクトマネジメント&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;時系列-を軸とした場合の例&#34;&gt;&lt;em&gt;時系列&lt;/em&gt; を軸とした場合の例&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;要件定義&lt;/li&gt;
&lt;li&gt;設計フェーズ&lt;/li&gt;
&lt;li&gt;実装フェーズ&lt;/li&gt;
&lt;li&gt;検収フェーズ&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;場所-担当-を軸とした場合の例&#34;&gt;&lt;em&gt;場所(担当)&lt;/em&gt; を軸とした場合の例&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;クライアント&lt;/li&gt;
&lt;li&gt;社内&lt;/li&gt;
&lt;li&gt;外注&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;など。&lt;/p&gt;

&lt;h2 id=&#34;wbsの型&#34;&gt;WBSの型&lt;/h2&gt;

&lt;h3 id=&#34;ツリー型構造&#34;&gt;ツリー型構造&lt;/h3&gt;

&lt;h4 id=&#34;メリット&#34;&gt;メリット&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;構造や因果関係が理解し易い&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;デメリット&#34;&gt;デメリット&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;詳細を記述しにくい&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;備考&#34;&gt;備考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;チャート型（Chart form）とも呼ぶ&lt;/li&gt;
&lt;li&gt;大項目を洗い出す時や、初期タスクの洗い出しやすい&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;一覧型構造&#34;&gt;一覧型構造&lt;/h3&gt;

&lt;h4 id=&#34;メリット-1&#34;&gt;メリット&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;詳細が記述し易い&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;デメリット-1&#34;&gt;デメリット&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;構造がわかりにくい&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;備考-1&#34;&gt;備考&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;表型（Tabular form）とも呼ぶ&lt;/li&gt;
&lt;li&gt;ある程度大項目がわかっている場合、責任分担やスケジュールを盛り込みやすい&lt;/li&gt;
&lt;li&gt;WEBプロジェクトでは、こちらが利用されるケースか多い&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;分割された項目&#34;&gt;分割された項目&lt;/h2&gt;

&lt;p&gt;どういった軸で分解するか決めた後、&lt;br /&gt;
更に細分化して項目を分解していく必要がある。&lt;/p&gt;

&lt;h3 id=&#34;レベル毎の分解&#34;&gt;レベル毎の分解&lt;/h3&gt;

&lt;p&gt;分割された項目は、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;大項目（1レベル）&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;中項目（2レベル）&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;小項目（3レベル）&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;といった階層構造で整理していく。&lt;/p&gt;

&lt;h3 id=&#34;各担当の必要な分解レベル&#34;&gt;各担当の必要な分解レベル&lt;/h3&gt;

&lt;p&gt;WBSを閲覧する担当者によって、&lt;em&gt;「分割された項目」&lt;/em&gt; つまり、&lt;br /&gt;
WBSの分解が必要なレベルは異なる。&lt;/p&gt;

&lt;p&gt;オーナーレベル（事業責任者等）であれば、2レベル程度で良いが、&lt;br /&gt;
作業者レベルの場合は、6レベルあたり(作業単位で分解されている方が良い)&lt;/p&gt;

&lt;h3 id=&#34;ワーク-パッケージ&#34;&gt;ワーク・パッケージ&lt;/h3&gt;

&lt;p&gt;尚、最小単位まで分解された作業単位は「&lt;strong&gt;ワーク・パッケージ&lt;/strong&gt;」と呼ばれて、&lt;br /&gt;
PMBOKでは「&lt;strong&gt;最下位レベルの要素成果物&lt;/strong&gt;」と定義されている。&lt;/p&gt;

&lt;p&gt;どこまで分解するかの指標としては、以下のような形が良いとされている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;em&gt;経験が浅い・新規プロジェクト など&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;不確実性な要素が存在しているケースは、なるべく細かくブレークダウンしたほうが良い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;em&gt;経験がある・スキルが高いメンバーがアサインしている など&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;安定している場合はそこまで細かくブレークダウンしなくても良い&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;ワーク-パッケージの内容が適切かどうか&#34;&gt;ワーク・パッケージの内容が適切かどうか&lt;/h3&gt;

&lt;p&gt;分解されたワーク・パッケージの内容が適切かどうか確認するには、&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;ひとつのワーク・パッケージに複数の人が担当者に任命されている

&lt;ul&gt;
&lt;li&gt;適切な作業分解ができていない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ワーク・パッケージ内の &lt;em&gt;各作業間に長い空き時間にある&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;待機工数が発生している&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ワーク・パッケージ内の &lt;em&gt;作業の一部に特化したリスクがあり、切り分けが必要&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;適切な作業分解ができていない&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;ワーク・パッケージの &lt;em&gt;内容を明確に理解していないステークホルダーがいる&lt;/em&gt;

&lt;ul&gt;
&lt;li&gt;追加項目が発生する可能性がある&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;などを確認すると良い。&lt;/p&gt;

&lt;h2 id=&#34;作成時の注意点&#34;&gt;作成時の注意点&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;WBSで最重要のものは「チーム全員でレビューをおこなう事」

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;不確実性の程度認識&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;管理の強弱を知る&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;不確実性とは&#34;&gt;不確実性とは&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;時間に制約がある&lt;/li&gt;
&lt;li&gt;特殊なリソース調達が必要&lt;/li&gt;
&lt;li&gt;アウトプット結果が具体的に見えないタスク&lt;/li&gt;
&lt;li&gt;アウトプットの完成度が不透明&lt;/li&gt;
&lt;li&gt;技術麺での新規性が高い&lt;/li&gt;
&lt;li&gt;経験者がいない技術&lt;/li&gt;
&lt;li&gt;前提、仮定が狂いやすい作業&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;管理の強弱とは&#34;&gt;管理の強弱とは&lt;/h3&gt;

&lt;p&gt;内製で行う作業なのか、ベンダーに発注を行う作業なのか？&lt;br /&gt;
ベンター作業との細かい &lt;em&gt;依存関係を明確に認識&lt;/em&gt; しておく為。&lt;/p&gt;

&lt;h3 id=&#34;レビュー時の観点&#34;&gt;レビュー時の観点&lt;/h3&gt;

&lt;p&gt;以下の点に注意して内容を確認する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;要素成果物に抜けがないか&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;ブレークダウンは適切か&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;責任は明確化されているか&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;wbs更新時のルール策定&#34;&gt;WBS更新時のルール策定&lt;/h2&gt;

&lt;p&gt;メンバーの解釈・裁量で期限設定やチケットの追加等を行われた場合、&lt;br /&gt;
WBSの管理が難しくなりWBSの信用性がなくなる。&lt;br /&gt;
結果として円滑なプロジェクト進行が難しくなる為、以下の点に注意する。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WBSの管理者・更新者をチームで決めてルール化する&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;更新後の周知ルールを定める&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;備考-2&#34;&gt;備考&lt;/h2&gt;

&lt;p&gt;一般的にはWBSは、&lt;em&gt;4つ程度の1レベルが存在&lt;/em&gt; している程度が適正だと言われている。&lt;/p&gt;

&lt;p&gt;既に利用しているWBSのテンプレートが存在している場合は、&lt;br /&gt;
&lt;em&gt;新たにWBSを作成するプロジェクトがそのフォーマットに適しているのか&lt;/em&gt; を考えて引っ張られないようにする。&lt;/p&gt;

&lt;p&gt;WBSは作成した後、その情報を元として後々の作業で利用される事が多い。&lt;br /&gt;
主にスケジュール管理に使用される事が多いため、&lt;em&gt;各要素にユニークな識別子&lt;/em&gt; を振り分ける事が一般的。&lt;br /&gt;
&lt;em&gt;識別子&lt;/em&gt; は、&lt;em&gt;スケジュール&lt;/em&gt; / &lt;em&gt;予算見積書&lt;/em&gt; など、&lt;em&gt;様々な文書に利用できる&lt;/em&gt; 為、&lt;br /&gt;
識別子が一致していれば会計処理がスムーズにする事も可能。&lt;br /&gt;
コスト削減する場合にも、どの作業を削れば良いかが分かりやすくメリットがある。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>TIL - ReactStudy#01</title>
      <link>https://kglabo.com/blog/react-study-01/</link>
      <pubDate>Sat, 18 Feb 2017 00:00:00 +0000</pubDate>
      
      <guid>https://kglabo.com/blog/react-study-01/</guid>
      <description>

&lt;h2 id=&#34;概要&#34;&gt;概要&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;http://basic-react.axlight.com/html/&#34;&gt;React基礎&lt;/a&gt;を参考にしての学習。&lt;/p&gt;

&lt;h2 id=&#34;参考にしたサイト&#34;&gt;参考にしたサイト&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://basic-react.axlight.com/html/&#34;&gt;React基礎&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://postd.cc/learn-raw-react-no-jsx-flux-es6-webpack/&#34;&gt;生のReactを知ろう – JSX、Flux、ES6、Webpackを使わず…&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;学習内容&#34;&gt;学習内容&lt;/h2&gt;

&lt;p&gt;以下、&lt;a href=&#34;http://basic-react.axlight.com/html/&#34;&gt;React基礎&lt;/a&gt;より引用（個人用メモ）&lt;/p&gt;

&lt;h3 id=&#34;前置き&#34;&gt;前置き&lt;/h3&gt;

&lt;p&gt;Reactでコーディングする先は、&lt;strong&gt;ES2015(ES6)&lt;/strong&gt;を使うと便利になる。&lt;br /&gt;
んで、ES2015を利用する際は&lt;strong&gt;トランスパイル&lt;/strong&gt;が必要。&lt;br /&gt;
後々、&lt;strong&gt;JSX&lt;/strong&gt; を使うし相対的にES2015の敷居下がるよね？ 覚えよ？って記載されてた。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;ES2015(ES6)&lt;/strong&gt; - &lt;a href=&#34;http://qiita.com/tuno-tky/items/74ca595a9232bcbcd727&#34;&gt;コチラ&lt;/a&gt;によると、&lt;em&gt;ECMAScript6thEdition&lt;/em&gt; == &lt;em&gt;ES6&lt;/em&gt; の事。

&lt;ul&gt;
&lt;li&gt;当初は ES6の名前で発表されたらしいが、正式名称が*ECMAScript2015*になった事もあり、ES2015と呼ばれているとの事&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;トランスパイル&lt;/strong&gt; - ソースコードからソースコードへのコンパイル&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JSX&lt;/strong&gt; - &lt;a href=&#34;http://qiita.com/ConquestArrow/items/29fc478f48862a4d14fb&#34;&gt;コチラ&lt;/a&gt;によると、ReactのJXSとAltJSのJSXとAdobeJSXがあるらしい

&lt;ul&gt;
&lt;li&gt;つまりどういうことだってばよ？&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;es2015について&#34;&gt;ES2015について&lt;/h3&gt;

&lt;p&gt;ES2015でよく使う文法についての解説されていた。&lt;/p&gt;

&lt;h4 id=&#34;const-let&#34;&gt;const/let&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;const&lt;/code&gt; - 再代入しない&lt;br /&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;let&lt;/code&gt; - 再代入できる&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;const x = 1;
let y = 2;
y = 3;

const z = { a: 4, b: 5 };
z.a = 6;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;var&lt;/code&gt;は消えた模様。&lt;/p&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;object-shorthand&#34;&gt;object shorthand&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;オブジェクトのプロパティ名と値の変数名が同じ場合、省略記法を使える&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;const foo = &#39;abc&#39;;
const bar = { foo }; // same as { foo: foo }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;destructuring-object&#34;&gt;destructuring object&lt;/h4&gt;

&lt;p&gt;&lt;em&gt;destructuring assignment&lt;/em&gt; という簡便な記法が利用できる&lt;br /&gt;
特にオブジェクトについての記法を紹介されていた。&lt;br /&gt;
変数への代入だけでなく、関数のパラメータ宣言でも用いられるとの事。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const obj = { first: &#39;Ebisu&#39;, last: &#39;JS&#39; };
const { first, last } = obj;
// first === &#39;Ebisu&#39;, last === &#39;JS&#39;

function printName({ first, last }) { console.log(first, last); }
printName(obj);

// same as
// function printName(name) { console.log(name.first, name.last); }
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;アロー関数&#34;&gt;アロー関数&lt;/h4&gt;

&lt;p&gt;アロー関数
&lt;code&gt;() =&amp;gt; ...&lt;/code&gt; って言う記法。詳しくは&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/arrow_functions&#34;&gt;こちら&lt;/a&gt;&lt;br /&gt;
&lt;code&gt;this&lt;/code&gt;を一旦置いとくと、アロー関数は通常の関数の省力記法と考える事ができるとの事。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const f1 = function(x) { console.log(x); };
const f2 = (x) =&amp;gt; { console.log(x); };
// f1 and f2 is almost the same
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;code&gt;return&lt;/code&gt; 文が一つだけの場合は、文そのものを省略できる&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const f3 = (x) =&amp;gt; { return (x + 1); };
const f4 = (x) =&amp;gt; (x + 1);
// f3 and f4 is the same
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;カッコの省略も可能（任意）&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;const f5 = x =&amp;gt; x + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;Coffee Script&lt;/code&gt;で言うと、 &lt;code&gt;hoge = -&amp;gt;&lt;/code&gt;みたいなもん？&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;関数型のコーディングについて&#34;&gt;関数型のコーディングについて&lt;/h3&gt;

&lt;p&gt;Reactでコンポーネントを書く際には、&lt;strong&gt;関数型コーディング&lt;/strong&gt; の方が楽らしい。&lt;br /&gt;
その前提を前置きした上で、このプログラム中によく使う文法について説明されている。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;関数型コーディング&lt;/strong&gt;  - &lt;a href=&#34;http://qiita.com/stkdev/items/5c021d4e5d54d56b927c&#34;&gt;関数型プログラミングはまず考え方から理解しよう&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&#34;pure-function&#34;&gt;pure function&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;一般的に副作用がない関数&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;const pureFunc = (x) =&amp;gt; { let y = x + 1; return y; };

let y;
const notPure = (x) =&amp;gt; { y = x + 1; return y; };

const notPure2 = (x) =&amp;gt; { console.log(&#39;foo&#39;); return x + 1; };
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;logical-operators&#34;&gt;logical operators&lt;/h4&gt;

&lt;p&gt;論理演算子には &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; , &lt;code&gt;||&lt;/code&gt; , &lt;code&gt;!&lt;/code&gt; の3つがある。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x &amp;amp;&amp;amp; y&lt;/code&gt; は、xが &lt;strong&gt;falsy&lt;/strong&gt; の場合はx、違う場合はyになる

&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;falsy&lt;/strong&gt;とは、 &lt;code&gt;false&lt;/code&gt; , &lt;code&gt;null&lt;/code&gt; , &lt;code&gt;0&lt;/code&gt; , &lt;code&gt;&#39;&#39;&lt;/code&gt; などの値。詳しくは&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Glossary/Falsy&#34;&gt;こちら&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;x || y&lt;/code&gt; という表現は、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;falsy&lt;/code&gt; の場合は &lt;code&gt;y&lt;/code&gt; 、違う場合は &lt;code&gt;x&lt;/code&gt; になる&lt;/li&gt;
&lt;li&gt;&lt;code&gt;!x&lt;/code&gt; という表現は、 &lt;code&gt;x&lt;/code&gt; が &lt;code&gt;falsy&lt;/code&gt; の場合は &lt;code&gt;true&lt;/code&gt; 、違う場合は &lt;code&gt;false&lt;/code&gt; になる

&lt;ul&gt;
&lt;li&gt;&lt;code&gt;x&lt;/code&gt; は真偽値(boolean)でなくてもよいです&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;pre&gt;&lt;code&gt;0 &amp;amp;&amp;amp; 1
// 0

1 &amp;amp;&amp;amp; 2
// 2

0 || 1
// 1

1 || 2
// 1

!0
// true

!1
// false
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;ternary-operator&#34;&gt;ternary operator&lt;/h4&gt;

&lt;p&gt;三項演算子はよく使うとの事&lt;br /&gt;
&lt;code&gt;x ? y : z&lt;/code&gt; は &lt;code&gt;x&lt;/code&gt; がfalsyの場合はzであり、そうでない場合はyになります。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;0 ? 1 : 2
// 2

3 ? 4 : 5
// 4
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;filter&#34;&gt;filter&lt;/h4&gt;

&lt;p&gt;Array.filterは配列から部分配列を作る関数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/filter&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;引数で与えたテスト関数がtruthy(つまりfalsyでない)を返す要素の配列を返す。&lt;br /&gt;
配列は新しく作られますが、要素はコピーされない。&lt;br /&gt;
テスト関数にはアロー関数を使うと簡便に書くことができます。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1, 2, 3, 4].filter((x) =&amp;gt; (x &amp;gt; 2))
// [3, 4]

[&#39;a&#39;, &#39;ab&#39;, &#39;abc&#39;, &#39;abcd&#39;].filter((x) =&amp;gt; (x.length &amp;lt;= 2))
// [&#39;a&#39;, &#39;ab&#39;]

[0, 1, 2, &#39;&#39;, &#39;a&#39;, false, true].filter((x) =&amp;gt; (x));
// [1, 2, &#39;a&#39;, true]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h4 id=&#34;map&#34;&gt;map&lt;/h4&gt;

&lt;p&gt;Array.mapは配列から要素ごとに変換して新しい配列を作る関数&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://developer.mozilla.org/ja/docs/Web/JavaScript/Reference/Global_Objects/Array/map&#34;&gt;参考&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;引数で与えられた変換関数で返される値を要素にもつ配列を返します。&lt;br /&gt;
配列は新しく作られる。要素数は変化しない。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[1, 2, 3, 4].map((x) =&amp;gt; (x * 2))
// [2, 4, 6, 8]

[&#39;a&#39;, &#39;ab&#39;, &#39;abc&#39;, &#39;abcd&#39;].map((x) =&amp;gt; (x.length))
// [1, 2, 3, 4]

[1, 2, &#39;a&#39;, &#39;b&#39;].map((x) =&amp;gt; (&#39;あ&#39; + x))
// [&#39;あ1&#39;, &#39;あ2&#39;, &#39;あa&#39;, &#39;あb&#39;]
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;
</description>
    </item>
    
  </channel>
</rss>